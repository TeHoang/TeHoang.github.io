---
layout: post
title: BackDoorCTF2023
date: 2023-12-20 13:06 +0700
tags: [crypto, LLL, CTF, RSA, ECC]
categories: [CTF Writeups]
math: true
---

Cuối tuần rồi mình có tham gia chơi BackDoorCTF cùng blackpinker, đây là lời giải của mình cho một vài bài crypto mà mình làm được trong kì thi.

![AAA](/assets/img/backdoorctf2023/image.png)

## Mini RSA

![Mini RSA](/assets/img/backdoorctf2023/MiniRSA.png)

Script đề bài:

```python
from Crypto.Util.number import getPrime , bytes_to_long , GCD
import random
import time

random.seed(time.time())
flag = b"flag{REDACTED}" #Flag has been removed

KEY_SIZE = 512
RSA_E = 3

def fast_exp(a, b, n):
    output = 1
    while b > 0:
        if b & 1:
            output = output * a % n
        a = a * a % n
        b >>= 1 
    return output    

def check(p, q, n):
    a_ = random.randint(1, 100)
    b_ = random.randint(1, 100)
    s = fast_exp(p, fast_exp(q, a_, (p - 1) * (q - 1)), n)
    t = fast_exp(q, fast_exp(p, b_, (p - 1) * (q - 1)), n)
    result = s + t
    print(result)

def gen_RSA_params(N, e):
    p = getPrime(N)
    q = getPrime(N)

    while GCD(e, (p - 1) * (q - 1)) > 1:
        p = getPrime(N)
        q = getPrime(N)

    n = p * q

    check(p, q, n) 
    return (p, q, n)

p, q, n = gen_RSA_params(KEY_SIZE, RSA_E) 

m = bytes_to_long(flag)
c = pow(m, RSA_E, n)

print(c)
print(n)
```

Nhìn chung thì đây là 1 bài RSA với `e = 3`, check file output thì chúng ta có:

```
s+t=24986288511406610689718446624210347240800254679541887917496550238025724025245366296475758347972917098615315083893786596239213463034880126152583583770452304
c=5926440800047066468184992240057621921188346083131741617482777221394411358243130401052973132050605103035491365016082149869814064434831123043357292949645845605278066636109516907741970960547141266810284132826982396956610111589
n=155735289132981544011017189391760271645447983310532929187034314934077442930131653227631280820261488048477635481834924391697025189196282777696908403230429985112108890167443195955327245288626689006734302524489187183667470192109923398146045404320502820234742450852031718895027266342435688387321102862096023537079
```

![smol](/assets/img/backdoorctf2023/e=3.png)

Đầu tiên mình nhận thấy `c` khá nhỏ so với `n`, từ đây mình có thể lấy căn bậc $3$ để thu hồi lại flag 

Solve script của mình:
```python
from Crypto.Util.number import long_to_bytes as ltb  
from sage.all import * 

c=5926440800047066468184992240057621921188346083131741617482777221394411358243130401052973132050605103035491365016082149869814064434831123043357292949645845605278066636109516907741970960547141266810284132826982396956610111589

m = ZZ(c).nth_root(3)

print(ltb(m).decode())

# flag{S0_y0u_c4n_s0lv3_s0m3_RSA}
```

## Mini RSA 2 

![MiniRSA2](/assets/img/backdoorctf2023/s+t=p+q.png)

Bài này script cũng tương tự như bài trước, chỉ khác rằng lúc này `e = 65537` thay vì `e = 3`. Bây giờ thì mình không thể sử dụng cách giải cũ nữa, tuy nhiên ở bài trước chúng ta có đại lượng `s + t` chưa sử dụng đến 

Trong đó: $s = p^x$ và $ t = q^y$ với $x, y$ nào đó 

Ở đây sẽ có 2 loại: 

1. Bạn là người siêng năng và sẽ chứng minh `s + t = p + q`

2. Bạn lười như mình và nhận thấy `s + t` chỉ có $513$ bits mà $p$ và $q$ đều là các số $512$ bits $\Rightarrow$ `s + t = p + q`

Khi đã có `p + q` thì mình chỉ cần tính `phi = (p - 1) * (q - 1) = n - (p + q) + 1` và lấy flag hoy 

```python
from Crypto.Util.number import long_to_bytes as ltb  
from sage.all import * 

st=19238118289292540845900132045328657353776835000175884072088390761517035980189490490459144989703825736320337279576084998885094661611740596902279433080118842
c=8706151122704717355844546946300718218661297718003809762659247903847434328687915436733170976217817899448539289359073472514594584336897461146424215943312922513357040989774130659844482065845748436287563176648482538678604968897565248411495214863860346421741054695295323750935794123435244378357713784569300292101
n=91006417473818125376038413443680810078297391307262694881962992972007772034646331080442026536488576075677538183326514650683359389396367200966050480101000687177953951819685597201494449347363819516742644021041231090322946128861477233797216337306770224218011823327837033401012386386102401543925525885359433574841

print(st.bit_length()) # 513

phi = n - st + 1 
e = 65537

d = pow(e, -1, phi)

print(ltb(pow(c, d, n)).decode())

# flag{I_4m_5tuck_0n_Th3_pl4n3t_Eg0_s4ve_M3}
```

## Something in common

![Alt text](/assets/img/backdoorctf2023/SIC.png)

Script của đề bài:

```python
from Crypto.Util.number import *

flag = "This flag has been REDACTED"
moduli = "This array has been REDACTED"

m = bytes_to_long(flag.encode())
e = 3
remainders = [pow(m,e,n) for n in moduli]

f = open('output.txt','w')
for i in range(len(moduli)):
    f.write(f"m ^ e mod {moduli[i]} = {remainders[i]}\n")
f.write(f"\ne = {e}")
f.close()
```

Đúng như description, đây là một bài RSA nhưng encrypt `m` $7$ lần thay vì $1$ lần

Nhìn vào file output ta có:
```
m ^ e mod 231689896592553079225008346159565141292942746185614335113030628126523977770897610833 = 70932244057518414814271820586538428333420562252483260602196856595136636875881109254
m ^ e mod 7171431858055720778675521 = 6776581747370220150625940
m ^ e mod 66926822362327139196541990168817936306935699 = 48565469191356626147008517582743644359421796
m ^ e mod 437335592290538364420374052921942150635299817629860400585996176158735283605573507708521 = 8794419984130129081066440741470891653922464557881503503363167507918405790466608773101
m ^ e mod 289641633885807692370107575915133663791 = 172864555741817549854149625512946760571
m ^ e mod 667489211907833441904090408183964916738111 = 123698332225047871848637413013333477895868
m ^ e mod 3567528272153764003837574317682649383619949327607 = 2621823962661199268500092259451160990545103771980

e = 3
```

Ở đây một lần nữa chúng ta gặp lại `e = 3`, vậy liệu mình có thể sử dụng lại cách như bài Mini RSA hay không?

Thật ra mình cũng chưa check (do mình chả thấy cái $c_i$ nào quá bé so với $n_i$ cả) =))). Nhưng mà mình tận dụng việc tác giả encrypt cùng `m` $7$ lần bằng cách sử dụng Thặng dư Trung Hoa

Ta sẽ thu được $c \equiv m^3 \pmod{\prod_{i}{n_i}}$. Với $c$ rất bé so với $\prod_{i}{n_i}$, lúc này chúng ta có thể lấy căn bậc $3$ như bài Mini RSA 1 để lấy flag 

```python
from sage.all import * 
from Crypto.Util.number import long_to_bytes as ltb 

mod = [231689896592553079225008346159565141292942746185614335113030628126523977770897610833, 7171431858055720778675521, 66926822362327139196541990168817936306935699, 437335592290538364420374052921942150635299817629860400585996176158735283605573507708521, 289641633885807692370107575915133663791, 667489211907833441904090408183964916738111, 3567528272153764003837574317682649383619949327607]
rem = [70932244057518414814271820586538428333420562252483260602196856595136636875881109254, 6776581747370220150625940, 48565469191356626147008517582743644359421796, 8794419984130129081066440741470891653922464557881503503363167507918405790466608773101, 172864555741817549854149625512946760571, 123698332225047871848637413013333477895868, 2621823962661199268500092259451160990545103771980]

f = crt(rem, mod)

print(product(mod).bit_length()) # 1221

print(ZZ(f).bit_length()) # 1053

print(ltb(ZZ(f).nth_root(3)).decode())

# flag{Wh4t_d0_y0u_m34n_1t_h4s_t0_b3_co-pr1m3}
```

## PRSA 

![Alt text](/assets/img/backdoorctf2023/PRSA.png)

Script của đề bài 

```python
from sage.all import *
from Crypto.Util.number import bytes_to_long, getPrime

import random
import time
random.seed(time.time())

message = b'flag{REDACTED}' ## the flag has been removed
F.<x> = PolynomialRing(GF(2), x)

p, q = [F.irreducible_element(random.randint(2 ** 10, 2 ** 12)) for _ in range(2)]
R.<y> = F.quotient_ring(p * q)

n = sum(int(bit) * y ** (len(bin(bytes_to_long(message))[2:]) - 1 - i) for i, bit in enumerate(bin(bytes_to_long(message))[2:]))

e = 2 ** 256
c = n ** e 

print(e) ## to be given to the user
print(c) ## to be given to the user
print(p * q) ## to be given to the user

```

Tiếp tục là $1$ bài về RSA nhưng không dựa vào tập $Z/nZ$ mà chúng ta vẫn hay sử dụng, thay vào đó là trên tập các đa thức $R[x] = GF_2[x]/(p[x] * q[x])$

Cách mình tiếp cận những bài này chính là nghĩ về RSA thông thường chúng ta làm như thế nào rồi chuyển nó về tập mà chúng ta đang xét 

RSA thông thường:

Khởi tạo:

Tạo ra một con $n = pq$ với $p$, $q$ là 2 số nguyên tố sao cho từ $n$ chúng ta không thể phân tích ngược lại $p$ và $q$

Encryption: 

Giả sử chúng ta muốn encrypt plaintext $m$, chúng ta sẽ đi tính $c \equiv m^e \pmod{n}$. Lúc này $c$ chính là ciphertext 

Decryption: 

Tính $d$ sao cho $ed \equiv 1 \pmod{\phi(n)}$ với $\phi(n)$ chính là phi hàm Euler của $n$ (ta cần tính $\phi(n)$ là do $a^{\phi(n)} \equiv 1 \pmod{n}$ $\forall a$ sao cho $(a, n) = 1$)

Lúc này ta sẽ có thể decrypt $c$ và thu lại $m$ như sau:
$m \equiv c^d \pmod{n}$

Vậy vì sao RSA thông thường an toàn? 

Đó là do chúng ta không thể phân tích được $p$ hay $q$ từ $n$. Tuy nhiên trong bài toán mà chúng ta đang xét, từ đa thức $p * q$, chúng ta có thể dễ dàng phân tích ngược lại đa thức $p$, $q$

![Alt text](/assets/img/backdoorctf2023/factorpq.png)

Việc tiếp theo mà chúng ta cần làm chính là tính xem $\phi(n)$ (từ đây mình sẽ gọi nó là bậc của $R[x]$) bằng bao nhiêu? 

Và từ đây mình xin phép giới thiệu 

### Ngu lần 1 

Mình đã đi tính bậc 1 cách ngây thơ đó chính là sử dụng hàm `.order()` trong `sage`

![Alt text](/assets/img/backdoorctf2023/this-guy-calculate-multiplicative-order-using-order()-lmaoooo.png)

Lúc này mình nhận thấy bậc mà mình đã tính ra chia hết cho $e$, tức $(o, e) \neq 1$ mà như vậy thì làm sao mình có thể tạo ra con $d$ như lúc làm bình thường được? Thế là mình đã thử rất nhiều attack khác nhau đến khi mình bí ý tưởng thì mình mới check lại xem bản thân đã tính bậc đúng chưa.

![Alt text](/assets/img/backdoorctf2023/issue-of-skill.png)

Bạn có nhận ra mình sai ở đâu không =)) 

Đúng là mình đã tính bậc đúng, nhưng là bậc đối với phép cộng chứ không phải là phép nhân mà mình đang cần tìm lmaoooo.

Sau đó mình đã tính lại bằng hàm `.multiplicative_order()` thay vì `.order()` và nhận được dòng lỗi: 

```AttributeError: 'PolynomialQuotientRing_generic_with_category' object has no attribute 'multiplicative_order'```

Vậy là trong `sage` không có cài đặt sẵn tính bậc đối với phép nhân trong `PolynomialQuotientRing`. Mình đành lên mạng tra [công thức tính](https://ask.sagemath.org/question/37287/how-to-find-the-multiplicative-order-of-an-element-in-a-quotient-ring-over-finite-field/) 

Qua đó mình biết bậc mình cần tính `o = lcm([2^p.degree() - 1, 2^q.degree() - 1])`

Check lại (sai nữa thì ko biết nói gì, skill issue cực mạnh):

![Alt text](/assets/img/backdoorctf2023/skill-issue.png)

Hên quá nó đúng rồi =))) 

Mình đã có hết mọi con số mình cần rồi, giờ thì lấy flag thui :p


```python
from sage.all import *
from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes as ltb 
import random
import time

F.<x> = PolynomialRing(GF(2), x)

pq = F(x^4547 + x^3524 + x^3518 + x^3517 + x^3512 + x^1072 + x^1070 + x^1041 + x^1035 + x^49 + x^47 + x^43 + x^42 + x^41 + x^40 + x^37 + x^35 + x^18 + x^11 + x^5 + 1)

# Factor p*q -> p, q
p, q = F(x^1035 + x^12 + x^6 + x^5 + 1), F(x^3512 + x^37 + x^35 + x^6 + 1)

R.<y> = F.quotient_ring(p * q)
Rp.<rp> = F.quotient_ring(p)
Rq.<rq> = F.quotient_ring(q)

c = ...

e = 115792089237316195423570985008687907853269984665640564039457584007913129639936

M = lcm([2^p.degree() - 1, 2^q.degree() - 1])

d = pow(e, -1, M)

dec = (c ** d).list()[::-1]

t = "".join(str(i) for i in dec)

from Crypto.Util.number import long_to_bytes as ltb 

print(ltb(int(t, 2)).decode())

# flag{S0_1mPL3m3n71nG_R54_0n_P0lYn0m1aL5_1n5734d_d1dn7_w0rk_hUh!!?}
```

Lười quá...có gì lúc sau mình add tiếp những bài còn lại