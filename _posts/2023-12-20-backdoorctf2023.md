---
layout: post
title: BackDoorCTF2023
date: 2023-12-20 13:06 +0700
tags: [crypto, LLL, CTF, RSA, ECC]
categories: [CTF Writeups]
math: true
---

Cuối tuần rồi mình có tham gia chơi BackDoorCTF cùng blackpinker, đây là lời giải của mình cho một vài bài crypto mà mình làm được trong kì thi.

![AAA](/assets/img/backdoorctf2023/image.png)

## Mini RSA

![Mini RSA](/assets/img/backdoorctf2023/MiniRSA.png)

Script đề bài:

```python
from Crypto.Util.number import getPrime , bytes_to_long , GCD
import random
import time

random.seed(time.time())
flag = b"flag{REDACTED}" #Flag has been removed

KEY_SIZE = 512
RSA_E = 3

def fast_exp(a, b, n):
    output = 1
    while b > 0:
        if b & 1:
            output = output * a % n
        a = a * a % n
        b >>= 1 
    return output    

def check(p, q, n):
    a_ = random.randint(1, 100)
    b_ = random.randint(1, 100)
    s = fast_exp(p, fast_exp(q, a_, (p - 1) * (q - 1)), n)
    t = fast_exp(q, fast_exp(p, b_, (p - 1) * (q - 1)), n)
    result = s + t
    print(result)

def gen_RSA_params(N, e):
    p = getPrime(N)
    q = getPrime(N)

    while GCD(e, (p - 1) * (q - 1)) > 1:
        p = getPrime(N)
        q = getPrime(N)

    n = p * q

    check(p, q, n) 
    return (p, q, n)

p, q, n = gen_RSA_params(KEY_SIZE, RSA_E) 

m = bytes_to_long(flag)
c = pow(m, RSA_E, n)

print(c)
print(n)
```

Nhìn chung thì đây là 1 bài RSA với `e = 3`, check file output thì chúng ta có:

```
s+t=24986288511406610689718446624210347240800254679541887917496550238025724025245366296475758347972917098615315083893786596239213463034880126152583583770452304
c=5926440800047066468184992240057621921188346083131741617482777221394411358243130401052973132050605103035491365016082149869814064434831123043357292949645845605278066636109516907741970960547141266810284132826982396956610111589
n=155735289132981544011017189391760271645447983310532929187034314934077442930131653227631280820261488048477635481834924391697025189196282777696908403230429985112108890167443195955327245288626689006734302524489187183667470192109923398146045404320502820234742450852031718895027266342435688387321102862096023537079
```

![smol](/assets/img/backdoorctf2023/e=3.png)

Đầu tiên mình nhận thấy `c` khá nhỏ so với `n`, từ đây mình có thể lấy căn bậc $3$ để thu hồi lại flag 

Solve script của mình:
```python
from Crypto.Util.number import long_to_bytes as ltb  
from sage.all import * 

c=5926440800047066468184992240057621921188346083131741617482777221394411358243130401052973132050605103035491365016082149869814064434831123043357292949645845605278066636109516907741970960547141266810284132826982396956610111589

m = ZZ(c).nth_root(3)

print(ltb(m).decode())

# flag{S0_y0u_c4n_s0lv3_s0m3_RSA}
```

## Mini RSA 2 

![MiniRSA2](/assets/img/backdoorctf2023/s+t=p+q.png)

Bài này script cũng tương tự như bài trước, chỉ khác rằng lúc này `e = 65537` thay vì `e = 3`. Bây giờ thì mình không thể sử dụng cách giải cũ nữa, tuy nhiên ở bài trước chúng ta có đại lượng `s + t` chưa sử dụng đến 

Trong đó: $s = p^x$ và $ t = q^y$ với $x, y$ nào đó 

Ở đây sẽ có 2 loại: 

1. Bạn là người siêng năng và sẽ chứng minh `s + t = p + q`

2. Bạn lười như mình và nhận thấy `s + t` chỉ có $513$ bits mà $p$ và $q$ đều là các số $512$ bits $\Rightarrow$ `s + t = p + q`

Khi đã có `p + q` thì mình chỉ cần tính `phi = (p - 1) * (q - 1) = n - (p + q) + 1` và lấy flag hoy 

```python
from Crypto.Util.number import long_to_bytes as ltb  
from sage.all import * 

st=19238118289292540845900132045328657353776835000175884072088390761517035980189490490459144989703825736320337279576084998885094661611740596902279433080118842
c=8706151122704717355844546946300718218661297718003809762659247903847434328687915436733170976217817899448539289359073472514594584336897461146424215943312922513357040989774130659844482065845748436287563176648482538678604968897565248411495214863860346421741054695295323750935794123435244378357713784569300292101
n=91006417473818125376038413443680810078297391307262694881962992972007772034646331080442026536488576075677538183326514650683359389396367200966050480101000687177953951819685597201494449347363819516742644021041231090322946128861477233797216337306770224218011823327837033401012386386102401543925525885359433574841

print(st.bit_length()) # 513

phi = n - st + 1 
e = 65537

d = pow(e, -1, phi)

print(ltb(pow(c, d, n)).decode())

# flag{I_4m_5tuck_0n_Th3_pl4n3t_Eg0_s4ve_M3}
```

## Something in common

![Alt text](/assets/img/backdoorctf2023/SIC.png)

Script của đề bài:

```python
from Crypto.Util.number import *

flag = "This flag has been REDACTED"
moduli = "This array has been REDACTED"

m = bytes_to_long(flag.encode())
e = 3
remainders = [pow(m,e,n) for n in moduli]

f = open('output.txt','w')
for i in range(len(moduli)):
    f.write(f"m ^ e mod {moduli[i]} = {remainders[i]}\n")
f.write(f"\ne = {e}")
f.close()
```

Đúng như description, đây là một bài RSA nhưng encrypt `m` $7$ lần thay vì $1$ lần

Nhìn vào file output ta có:
```
m ^ e mod 231689896592553079225008346159565141292942746185614335113030628126523977770897610833 = 70932244057518414814271820586538428333420562252483260602196856595136636875881109254
m ^ e mod 7171431858055720778675521 = 6776581747370220150625940
m ^ e mod 66926822362327139196541990168817936306935699 = 48565469191356626147008517582743644359421796
m ^ e mod 437335592290538364420374052921942150635299817629860400585996176158735283605573507708521 = 8794419984130129081066440741470891653922464557881503503363167507918405790466608773101
m ^ e mod 289641633885807692370107575915133663791 = 172864555741817549854149625512946760571
m ^ e mod 667489211907833441904090408183964916738111 = 123698332225047871848637413013333477895868
m ^ e mod 3567528272153764003837574317682649383619949327607 = 2621823962661199268500092259451160990545103771980

e = 3
```

Ở đây một lần nữa chúng ta gặp lại `e = 3`, vậy liệu mình có thể sử dụng lại cách như bài Mini RSA hay không?

Thật ra mình cũng chưa check (do mình chả thấy cái $c_i$ nào quá bé so với $n_i$ cả) =))). Nhưng mà mình tận dụng việc tác giả encrypt cùng `m` $7$ lần bằng cách sử dụng Thặng dư Trung Hoa

Ta sẽ thu được $c \equiv m^3 \pmod{\prod_{i}{n_i}}$. Với $c$ rất bé so với $\prod_{i}{n_i}$, lúc này chúng ta có thể lấy căn bậc $3$ như bài Mini RSA 1 để lấy flag 

```python
from sage.all import * 
from Crypto.Util.number import long_to_bytes as ltb 

mod = [231689896592553079225008346159565141292942746185614335113030628126523977770897610833, 7171431858055720778675521, 66926822362327139196541990168817936306935699, 437335592290538364420374052921942150635299817629860400585996176158735283605573507708521, 289641633885807692370107575915133663791, 667489211907833441904090408183964916738111, 3567528272153764003837574317682649383619949327607]
rem = [70932244057518414814271820586538428333420562252483260602196856595136636875881109254, 6776581747370220150625940, 48565469191356626147008517582743644359421796, 8794419984130129081066440741470891653922464557881503503363167507918405790466608773101, 172864555741817549854149625512946760571, 123698332225047871848637413013333477895868, 2621823962661199268500092259451160990545103771980]

f = crt(rem, mod)

print(product(mod).bit_length()) # 1221

print(ZZ(f).bit_length()) # 1053

print(ltb(ZZ(f).nth_root(3)).decode())

# flag{Wh4t_d0_y0u_m34n_1t_h4s_t0_b3_co-pr1m3}
```

## PRSA 

![Alt text](/assets/img/backdoorctf2023/PRSA.png)

Script của đề bài 

```python
from sage.all import *
from Crypto.Util.number import bytes_to_long, getPrime

import random
import time
random.seed(time.time())

message = b'flag{REDACTED}' ## the flag has been removed
F.<x> = PolynomialRing(GF(2), x)

p, q = [F.irreducible_element(random.randint(2 ** 10, 2 ** 12)) for _ in range(2)]
R.<y> = F.quotient_ring(p * q)

n = sum(int(bit) * y ** (len(bin(bytes_to_long(message))[2:]) - 1 - i) for i, bit in enumerate(bin(bytes_to_long(message))[2:]))

e = 2 ** 256
c = n ** e 

print(e) ## to be given to the user
print(c) ## to be given to the user
print(p * q) ## to be given to the user

```

Tiếp tục là $1$ bài về RSA nhưng không dựa vào tập $Z/nZ$ mà chúng ta vẫn hay sử dụng, thay vào đó là trên tập các đa thức $R[x] = GF_2[x]/(p[x] * q[x])$

Cách mình tiếp cận những bài này chính là nghĩ về RSA thông thường chúng ta làm như thế nào rồi chuyển nó về tập mà chúng ta đang xét 

RSA thông thường:

Khởi tạo:

Tạo ra một con $n = pq$ với $p$, $q$ là 2 số nguyên tố sao cho từ $n$ chúng ta không thể phân tích ngược lại $p$ và $q$

Encryption: 

Giả sử chúng ta muốn encrypt plaintext $m$, chúng ta sẽ đi tính $c \equiv m^e \pmod{n}$. Lúc này $c$ chính là ciphertext 

Decryption: 

Tính $d$ sao cho $ed \equiv 1 \pmod{\phi(n)}$ với $\phi(n)$ chính là phi hàm Euler của $n$ (ta cần tính $\phi(n)$ là do $a^{\phi(n)} \equiv 1 \pmod{n}$ $\forall a$ sao cho $(a, n) = 1$)

Lúc này ta sẽ có thể decrypt $c$ và thu lại $m$ như sau:
$m \equiv c^d \pmod{n}$

Vậy vì sao RSA thông thường an toàn? 

Đó là do chúng ta không thể phân tích được $p$ hay $q$ từ $n$. Tuy nhiên trong bài toán mà chúng ta đang xét, từ đa thức $p * q$, chúng ta có thể dễ dàng phân tích ngược lại đa thức $p$, $q$

![Alt text](/assets/img/backdoorctf2023/factorpq.png)

Việc tiếp theo mà chúng ta cần làm chính là tính xem $\phi(n)$ (từ đây mình sẽ gọi nó là bậc của $R[x]$) bằng bao nhiêu? 

Và từ đây mình xin phép giới thiệu 

### Ngu lần 1 

Mình đã đi tính bậc 1 cách ngây thơ đó chính là sử dụng hàm `.order()` trong `sage`

![Alt text](/assets/img/backdoorctf2023/this-guy-calculate-multiplicative-order-using-order()-lmaoooo.png)

Lúc này mình nhận thấy bậc mà mình đã tính ra chia hết cho $e$, tức $(o, e) \neq 1$ mà như vậy thì làm sao mình có thể tạo ra con $d$ như lúc làm bình thường được? Thế là mình đã thử rất nhiều attack khác nhau đến khi mình bí ý tưởng thì mình mới check lại xem bản thân đã tính bậc đúng chưa.

![Alt text](/assets/img/backdoorctf2023/issue-of-skill.png)

Bạn có nhận ra mình sai ở đâu không =)) 

Đúng là mình đã tính bậc đúng, nhưng là bậc đối với phép cộng chứ không phải là phép nhân mà mình đang cần tìm lmaoooo.

Sau đó mình đã tính lại bằng hàm `.multiplicative_order()` thay vì `.order()` và nhận được dòng lỗi: 

```AttributeError: 'PolynomialQuotientRing_generic_with_category' object has no attribute 'multiplicative_order'```

Vậy là trong `sage` không có cài đặt sẵn tính bậc đối với phép nhân trong `PolynomialQuotientRing`. Mình đành lên mạng tra [công thức tính](https://ask.sagemath.org/question/37287/how-to-find-the-multiplicative-order-of-an-element-in-a-quotient-ring-over-finite-field/) 

Qua đó mình biết bậc mình cần tính `o = lcm([2^p.degree() - 1, 2^q.degree() - 1])`

Check lại (sai nữa thì ko biết nói gì, skill issue cực mạnh):

![Alt text](/assets/img/backdoorctf2023/skill-issue.png)

Hên quá nó đúng rồi =))) 

Mình đã có hết mọi con số mình cần rồi, giờ thì lấy flag thui :p


```python
from sage.all import *
from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes as ltb 
import random
import time

F.<x> = PolynomialRing(GF(2), x)

pq = F(x^4547 + x^3524 + x^3518 + x^3517 + x^3512 + x^1072 + x^1070 + x^1041 + x^1035 + x^49 + x^47 + x^43 + x^42 + x^41 + x^40 + x^37 + x^35 + x^18 + x^11 + x^5 + 1)

# Factor p*q -> p, q
p, q = F(x^1035 + x^12 + x^6 + x^5 + 1), F(x^3512 + x^37 + x^35 + x^6 + 1)

R.<y> = F.quotient_ring(p * q)
Rp.<rp> = F.quotient_ring(p)
Rq.<rq> = F.quotient_ring(q)

c = ...

e = 115792089237316195423570985008687907853269984665640564039457584007913129639936

M = lcm([2^p.degree() - 1, 2^q.degree() - 1])

d = pow(e, -1, M)

dec = (c ** d).list()[::-1]

t = "".join(str(i) for i in dec)

from Crypto.Util.number import long_to_bytes as ltb 

print(ltb(int(t, 2)).decode())

# flag{S0_1mPL3m3n71nG_R54_0n_P0lYn0m1aL5_1n5734d_d1dn7_w0rk_hUh!!?}
```

## Knapsack

![Alt text](/assets/img/backdoorctf2023/Knapsack.png)

Script đề bài:

```python
import random
import hashlib
from Crypto.Util.number import bytes_to_long
from Crypto.Cipher import AES

flag = b"The flag has been REDACTED"
secret = b"The seccret has been REDACTED"
key = hashlib.sha256(secret).digest()[:16]

cipher = AES.new(key, AES.MODE_ECB)
padded_flag = flag + b'\x00'*(-len(flag)%16)

ciphertext = cipher.encrypt(padded_flag)

f = open('output.txt','w')
f.write(f"Ciphertext: {ciphertext.hex()}\n\n")

arr = [ random.randint(1,1000000000000) for i in range(40) ]
k = bytes_to_long(secret)
s = 0
for i in range(40):
    if k&(1<<i):
        s+=arr[i]

f.write(f'numbers: {str(arr)[1:-1]}\nsum: {s}\n')
f.close()
```

Đọc một chút thì chúng ta sẽ biết rằng mục tiêu của bài sẽ là đi tìm `secret`

Ở đây thì phương trình có liên quan đến `secret` chính là

$$

s = \sum_{i=0}^{39}{b_i * arr_i}

$$

Trong đó thì $b_i \in \{0, 1\}$ chính là bit thứ $i$ của `secret`, còn `arr` chính là mảng các số được random mà đề đã cho chúng ta.   

Vậy thì mục tiêu của chúng ta sẽ là xác định $b_i$ $(0 \leq i \leq 39)$ từ `arr` và `s`. Sau đó thì ta có thể lấy lại `secret`

Nhìn chung thì đây là 1 bài subset sum cơ bản, chúng ta sẽ dùng LLL để giải bài này

Ở đây thì mình sẽ dùng script trong [lbc_toolkit của Joseph](https://github.com/josephsurin/lattice-based-cryptanalysis/blob/main/lbc_toolkit/problems/knapsack.sage) (goated tool)

```python
def subset_sum(weights, targets, modulus=None, N=None, lattice_reduction=None, verbose=False):
    verbose = (lambda *a: print('[subset_sum]', *a)) if verbose else lambda *_: None

    if type(weights[0]) is list:
        k = len(weights)
        n = len(weights[0])
    else:
        k = 1
        n = len(weights)
        weights = [weights]
        targets = [targets]

    if modulus is not None:
        density = n / (k * log(modulus, 2))
    else:
        density = n / (k * log(max(flatten(weights)), 2))
    verbose('Density:', round(density.n(), 4))

    N = N or ceil(sqrt((n+1)/4))
    B = 2 * Matrix.identity(n)
    B = B.augment(vector([0] * n))
    for j in range(k):
        B = B.augment(vector([N * a for a in weights[j]]))
    if modulus is not None:
        B = B.stack(Matrix.zero(k, n + 1).augment(N * modulus * Matrix.identity(k)))
    B = B.stack(vector([1] * (n + 1) + [N * s for s in targets]))

    verbose('Lattice dimensions:', B.dimensions())
    lattice_reduction_timer = cputime()
    if lattice_reduction:
        B = lattice_reduction(B)
    else:
        B = B.LLL()
    verbose(f'Lattice reduction took {cputime(lattice_reduction_timer):.3f}s')

    for row in B:
        if row[n] < 0:
            sol = [ZZ((x + 1)//2) for x in row[:n]]
        else:
            sol = [ZZ((1 - x)//2) for x in row[:n]]
        if any(x not in [0, 1] for x in sol):
            continue
        for j in range(k):
            t = sum(ZZ(e) * ZZ(a) for e, a in zip(sol, weights[j]))
            tj = targets[j]
            if modulus > 0:
                t %= modulus
                tj %= modulus
            if t != tj:
                break
        else:
            return sol
        
    return None

numbers = [600848253359, 617370603129, 506919465064, 218995773533, 831016169202, 501743312177, 15915022145, 902217876313, 16106924577, 339484425400, 372255158657, 612977795139, 755932592051, 188931588244, 266379866558, 661628157071, 428027838199, 929094803770, 917715204448, 103431741147, 549163664804, 398306592361, 442876575930, 641158284784, 492384131229, 524027495955, 232203211652, 213223394430, 322608432478, 721091079509, 518513918024, 397397503488, 62846154328, 725196249396, 443022485079, 547194537747, 348150826751, 522851553238, 421636467374, 12712949979]
sum = 7929089016814

print(subset_sum(numbers, sum, verbose=True))
```

Tuy nhiên trái ngược lại với mong đợi, mình đã không tìm được $b_i$

```
[subset_sum] Density: 1.0061
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.015s
None
```

Lúc này mình nhận ra rằng density của mảng quá cao so với thuật toán mà mình đang sử dụng 

Cụ thể trong [tutorial.pdf](https://github.com/josephsurin/lattice-based-cryptanalysis/blob/main/tutorial.pdf) của Joseph có note rằng: 

![Alt text](/assets/img/backdoorctf2023/density.png)

Rõ ràng $1.0061 > 0.9408$ cho nên có thể đây là lý do mà mình không LLL ra được đáp án, vậy thì tới đây các bạn sẽ làm gì?

Đối với mình thì mình sẽ đưa nó về những gì mình biết để giải :D. Mình không biết cách nào để giải bài knapsack density cao cả, do thế mình sẽ cố gắng khiến cho density thấp xuống. Vậy thì density được tính như thế nào?

Nhìn lại trong script của hàm `subset_sum` ta có:
```python
density = n / (k * log(max(flatten(weights)), 2))
```

Ở đây mình thấy density sẽ phụ thuộc vào $n$, $k$ và max($arr_i$) $n$, $k$ là $2$ số cố định rồi, vì thế mình chỉ có thể thay đổi các số trong `arr`. Tuy nhiên chúng ta sẽ phải thay đổi như thế nào? 

### Cách 1:

Mình sẽ nhân tất cả phần tử của `arr` một lượng `scale_factor` nào đó sao cho density mình đủ nhỏ để giải. Khi này mình tự gen số và nhận thấy cách này cũng không cho mình đáp án mà mình mong muốn

```python
scale_factor = 100000

arr = [ randint(1,1000000000000) for i in range(40) ]
arr_ = [scale_factor * x for x in arr]

for i in range(len(arr)):
    assert arr[i] * scale_factor == arr_[i]

k = bytes_to_long(secret)
s = 0
s_ = 0 

ans = [0 for i in range(40)]

for i in range(40):
    if k&(1<<i):
        s+=arr[i]
        s_ += arr_[i]
        ans[i] = 1

print(f"Wanted: {ans}")

sol = subset_sum(arr_, s_, verbose=True)

print(sol)
```

```
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0]
[subset_sum] Density: 0.7087
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.018s
None
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1]
[subset_sum] Density: 0.7087
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.021s
None
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1]
[subset_sum] Density: 0.7085
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.019s
None
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
[subset_sum] Density: 0.7084
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.015s
None
```

Do đó mình đã nghĩ thêm cách khác 

### Cách 2 

Do density chỉ phụ thuộc vào số lớn nhất trong trong `arr`, do đó mình sẽ thử chỉ thay đổi một vài số, tuy nhiên mình cần chọn những số không được cộng vào trong `s`, vì nếu như cộng vào trong `s` thì mình sẽ phải thay đổi `s` nhưng lúc làm bài thật thì làm sao mà mình biết được số nào được cộng và số nào không (mình đang đi tìm điều đó mà :D).

```python
secret = randbytes(5)
key = hashlib.sha256(secret).digest()[:16]

arr = [ randint(1,1000000000000) for i in range(40) ]

k = bytes_to_long(secret)
s = 0

ans = [0 for i in range(40)]

cnt = 0 

for i in range(40):
    if k&(1<<i):
        s+=arr[i]
        ans[i] = 1
    elif cnt < 10:
        arr[i] = 2^640 
        cnt += 1

print(f"Wanted: {ans}")

sol = subset_sum(arr, s, verbose=True)

print(sol)

```

Ở đây mình đã chọn 10 số đầu tiên không nằm trong tổng thành $2^{640}$

```
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1]
[subset_sum] Density: 0.0625
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.030s
[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1]
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1]
[subset_sum] Density: 0.0625
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.034s
None
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]
[subset_sum] Density: 0.0625
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.033s
None
(sage) elita@tehoang:/mnt/d/CTF/practice/idk/WU$ python3 test-knapsack.sage.py
Wanted: [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]
[subset_sum] Density: 0.0625
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.035s
[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]
```

Lúc thì ra kết quả, lúc thì không :D. Tuy nhiên như vậy là quá đủ so với 1 đứa như mình, mình thử luôn cách này cho bài mình đang làm nào :D.

```python
import itertools

poss = itertools.combinations(range(40), 4)

poss = list(poss)

t = 1

for cur_comb in poss:
    print(t)
    nums = [x for x in numbers]
    for a in cur_comb:
        nums[a] = 2 ** 640 
    x = subset_sum(nums, sum, verbose=True)
    if x != None:
        print(x)
        break
    t += 1 
```  

Như mình đã nói, lúc làm bài thật thì mình sẽ không biết những vị trí nào không được cộng vào trong tổng, do đó mình sẽ phải tạo ra tổ hợp các index để thay từ từ. Ở đây mình chọn thay 4 vị trí.

Chạy tới lần 305 thì mình đã có 1 vector thỏa yêu cầu :D 
```
305
[subset_sum] Density: 0.0625
[subset_sum] Lattice dimensions: (41, 42)
[subset_sum] Lattice reduction took 0.033s
[0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0]
```

Decrypt lấy flag thôi :D 

```python
t = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0]

from Crypto.Util.number import long_to_bytes as ltb

secret = "".join(str(x) for x in t[::-1])

secret = int(secret, 2)

secret = ltb(secret) 

key = hashlib.sha256(secret).digest()[:16]

cipher = AES.new(key, AES.MODE_ECB)

print(cipher.decrypt(bytes.fromhex(Ciphertext)))

# flag{N0t_r34dy_f0r_M3rkl3-H3llman}
```

Lười quá...có gì lúc sau mình add tiếp những bài còn lại